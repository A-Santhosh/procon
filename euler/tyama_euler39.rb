#!/usr/bin/ruby
require 'rational'
=begin
m**2-n**2 + 2*m*n + m**2+n**2 = 2m(m+n) = p
=end
=begin
dict={}
max=5000000
a=(max+1).times.map{|i|[0,i]}
m=2
while m**2<max
	n=1
	while n<m && 2*m*(m+n)<=max
		if n.gcd(m)==1
			k=1
			while k*2*m*(m+n)<=max
				_a_=[k*(m**2-n**2),k*2*m*n].sort
				if !dict[_a_]
					dict[_a_]=1
					a[k*2*m*(m+n)][0]+=1
				end
				k+=1
				#p [k,(m**2-n**2),m*n] if k*2*m*(m+n)==120
			end
		end
		n+=1
	end
	m+=1
end
1.step(max){|i|
	a[i]=a[i-1] if a[i-1][0]>=a[i][0]
}
#p a.uniq
=end
a=[[0, 0], [1, 12], [2, 60], [3, 120], [4, 240], [5, 420], [6, 720], [8, 840], [10, 1680], [12, 2520], [13, 4620], [16, 5040], [20, 9240], [25, 18480], [31, 27720], [40, 55440], [46, 110880], [50, 120120], [51, 166320], [53, 180180], [64, 240240], [80, 360360], [104, 720720], [105, 1081080], [124, 1441440], [130, 2042040], [135, 2162160], [142, 2882880], [158, 3603600], [168, 4084080]]
gets.to_i.times{
	n=gets.to_i
	#p a[n][1]
	p a.take_while{|e|e[1]<=n}.last[1]
}
__END__
1
1000